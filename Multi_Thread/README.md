# 多线程知识
讲解线程和进程的知识，实现多线程

## 第一章: 进程(Process)与线程(Thread)(Chapter1)
### 1、进程与线程相关概念
- 进程: 程序的一次执行过程, 是一个动态概念, 是系统资源分配的单位。
- 线程: 独立执行的路径。例如:main()称之为主线程, 为系统的入口, 用于执行整个程序。
- 在一个进程中可以包含有多个线程, 一个进程至少有一个线程, 线程是CPU调度和执行的单位。
- 在一个进程中如果开辟了多个线程, 线程的运行由调度器安排调度, 调度器与操作系统密切相关, 线程的先后顺序不能人为干预。
- **并发**: 同一个时刻，多个任务交替执行，造成一种"貌似同时"的错觉(任务之间来回切换，只不过速度比较快看起来就像一起"同时在执行)。单核CPU实现的多任务就是并发。
- **并行**: 同一个时刻多个任务真同时进行。多核CPU实现的多任务就是并行。

### 2、线程的使用
- 线程有以下两种方式可以进行创建
- 方法一: 继承Thread类并重写run方法
    - 其实Thread类中的run()也是实现的Runnable接口的run()。
    - Thread线程对象.start() 启动一个新线程，并执行线程对象的run()方法
    - Thread对象调用start()方法时，会先执行一个native方法 start0(), start0()会由JVM底层调用创建新线程，start0()被调用后该线程并不会立马执行，只是将该线程变成了"可运行状态"(线程状态中会讲解)，由CPU择机调用。
- 方法二: 实现Runnable接口(该接口中只有一个需要实现的方法就是run())
    - 推荐使用该方式: 因为可以避免单继承的影响
    - 无法直接使用.run()或者.start()方法，需要将Runnable实现对象传入Thread线程对象中(采用Thread的对应构造器即可)
    - 得到包裹Runnable对象的Thread线程对象后，再使用 线程对象.start()实现对start0的调用
    - 这种方式被称为"静态代理"模式
- 如果一个进程中存在多个线程, 会将等待所有子线程结束才会结束进程。注意: 并不是main线程结束就会结束整个进程。
- 继承Thread类方式 VS 实现Runnable接口
    - 这两种方式本质上没有任何区别，计算是方法一Thread也是继承了Runnable接口并重写了run()
    - 不过更推荐方式二实现Runnable接口再使用Thread对象进行代理。因为同一个Runnable接口实现类，可以被多个Thread对象进行代理进行代理从而实现多线程共享同一资源。并且避免了单继承的限制。

### 3、线程池
- 提前创建好多个线程, 放入线程池, 使用时直接获取, 使用完直接放回, 可以避免频繁创建和销毁, 实现重复利用
- ExecutorService: 线程池对象, 用于启动线程。
    - Executors.newFixedThreadPool(线程池大小): 创建一个ExecutorService对象
    - 对象.execute(Runnable接口实现类): 启动一个线程
    - 注意：使用完成后需要关闭线程池，线程池对象.shutdown()


## 第二章: Thread基本知识(Chapter2)
### 4、线程常见方法
- 线程对象(Thread对象)中常使用的方法:
    - 对象.setName(): 设置线程的名称(也可以在初始化Thread对象时指定)
    - 对象.getName(): 返回线程名称
    - 对象.start(): 使线程开始执行，本质上是使得JVM调用start0方法, 启动新线程
    - 对象.run(): 调用线程对象的run方法，其实底层是调用被代理的对象的run方法。
    - 对象.setPriority(): 更改线程优先级
    - 对象.getPriority(): 获取线程的优先级
    - 对象.interrupt(): 中断线程，并不是停止。会向线程对象抛出一个InterruptedException异常，如果存在捕获异常的代码则会被触发。(一般是用于唤醒正在sleep的线程对象)
    - 对象.join(): 让指定线程插队，阻塞当前正在执行的线程，等待插队的线程(特定线程)执行完毕后，继续执行剩下部分
    - Thread.sleep(): 让正在执行的线程休眠(暂停执行)
    - Thread.currentThread(): 得到当前位置正在执行的线程对象。
    - Thread.yield(): 进程礼让, 使当前正在执行的线程让出cpu资源, 让CPU去执行其他线程(不特定线程)执行，但礼让的时间(重新执行当前线程)不确定，也不一定能确定礼让成功。
- 细节:
    - 优先级的范围是:\[1,10], 优先级常见1,5,10
    - t1.interrupt()，并没有真正结束线程，一般用于唤醒正在休眠的线程，使其能进入下一次循环

### 5、线程终止方式
- 不推荐使用JDK提供的 线程对象.stop(), 或者 线程对象.destroy()方法
- 在实现Runnable接口类中，定义一个flag变量，用于控制run()方法的终止。同时我们再定义一个方法，用于外界调用来改变flag变量，从而实现对run()方法的停止。

### 6、Lambda表达式
- Lambda表达式使用的优势
    - 避免匿名内部类定义过多
    - 可以让你的代码看起来更简洁
    - 去掉了没有意义的代码部分
- Lambda表达式使用限制: 只能对函数式接口类才能使用
- 函数式接口定义: 
    - 任何接口, 如果只包含有唯一一个抽象方法, 那么它就是一个函数式子接口。
    - 对于函数式子接口, 我们可以通过lambda表达式类创建该接口的对象。

### 7、守护线程和用户线程
- 用户线程: 也叫做工作线程，当线程的任务执行完或者以通知的方式结束
- 守护线程: 一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束
- 例如: 在main线程中开启了一个无限循环的子线程，那就意味着当main线程执行完毕退出时，这个子线程仍然在一直执行着，并且永不会退出。如果向让这个子线程与main线程一同结束，则可以将子线程设置为守护线程。
- 对象.setDaemon(true): 将线程对象设置为守护线程，该守护线程为**所有非守护线程**服务，当所有非守护线程执行完毕，该守护线程才会立即停止执行。(注意，需要先将目标设置为守护线程，再start())
- 常见的守护线程: 垃圾回收机制

### 8、线程状态/生命周期
- [线程寿命周期图](线程生命周期图.png)
- Thread类中有一个枚举类public enum State，里面储存了线程的几种类型:
    - **NEW**: 尚未启动的线程，等待被start0()启动
    - **RUNNABLE**: 被start0启动后的线程进入到了可运行状态，其中该状态下也有两种子状态分别是Ready和Running, Ready是随时可以被调度器选中执行，Running是调度器已经选中正在执行的线程状态。
    - **BLOCKED**: 进入到等待同步代码块锁的线程, 当线程出现了同步锁的时候(解决线程安全)，该线程需要等待同步线程锁释放后，并获得锁才能进到RUNNABLE状态。
    - **WAITING**: 当调用 对象.wait()、线程对象.join()、LockSupport.park()，线程会进入到等待状态，直到被执行 对象.notify()、对象.notifyAll()、LockSupport.unpark(Thread)才会重新变成RUNNABLE状态。
    - **TIMED_WAITING**: 超时等待，Thread.sleep(time)、对象.wait(time)、对象.join(time)指定等待一段时间，当时间一到，则会自动变为RUNNABLE状态
    - **TERMINATED**: 终止状态，表示该线程执行完毕，释放资源。


## 第三章: 线程安全(Chapter3)
### 9、并发问题 
- 对于同一个对象(类)来说, 内部属性是唯一的, 如果多个线程对同一个对象进行操作内部属性则可能会出现线程不安全。
- 三个售票员对同一个售票亭进行售票:
    - 当三个线程同时进入到run中时, 都会执行循环抢票, 但可能会出现两个人抢到同一张票, 还可能会出现有人拿到第-1张票
    - 这就是线程对同一个对象的属性进行了操作导致, 线程不安全。

### 10、线程同步
- 为解决并发问题(多线程操作同一个资源, 会出现并发问题)，提出线程同步技术。
- 保证数据在任何同一时刻，最多有一个线程访问，由此能保证数据的完整性。线程同步其实是一种等待机制, 多个线程需要都需要操作同一个对象时，这些线程进入这到**对象的等待池**，只有一个线程可以操作，待其操作完成后再有一个线程可以操作。
- synchronized关键字: 用于线程同步的关键字
    - 方式一: 同步代码块
    ```
    synchronized (被同步对象) { // 只有取得对象的锁，才能执行下面的代码块
        // 需要被同步的代码块内容
    }
    ```
    - 方式二: 方法声明中使用，表示整个方法为同步方法，在同一时刻只有一个线程可以执行该m()方法
    ```
    public synchronized void m(){
        // 需要被同步的代码
    }
    ```
- 互斥锁
    - Java语言中引入了对象互斥锁的概念，用于保证数据操作的完整性
    - 每个对象都对应于一个可称为"互斥锁"的标记，这个标记用来保证任一时刻只有一个线程能访问该对象。
    - 当对象被 synchronized 修饰时，表明该对象在任一时刻只能由一个线程来访问。
    - 同步线程的局限性: 程序的执行效率较低。
    - 非静态方法使用 synchronized 修饰时，锁是加在this对象上的(换句话说只允许至多一个线程同时可以访问/使用该对象)。
    - 静态方法使用 synchronized 修饰时，锁加在当前类本身的(只允许至多一个线程可以访问/使用该类的任一对象)
    - 注意: 多个线程操作的 对象/类 必须是同一个才行。

### 11、死锁
- 多个线程各自占用一些共享资源, 并且互相等待其他线程占有的资源才能运行, 而导致两个或多个线程都在等待对方释放资源, 都停止执行的情形。某一同步块同时拥有两个以上对象的锁时, 就可能发生死锁问题
- 产生死锁的必要条件: 
    - 互斥: 一个资源每次只能被一个进程使用
    - 请求与保持: 一个进程因请求资源而被阻塞时, 对方一获得资源且保持不放。
    - 不剥夺: 进程已获得的资源, 在未使用前不能被强行剥夺
    - 循环等待: 如果进程之间形成一种收尾相接的循环等待资源关系
- 尽量避免一个synchronized块中又有一个synchronized块
- 释放锁的情况:
    - 当前线程的同步方法、同步代码块执行结束
    - 当前线程在同步代码块中遇见break(跳出代码块)，或在同步方法中return(退出方法)
    - 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception
    - 当前线程在同步代码块、同步方法中执行了 对象.wait()方法，则当前线程暂停，并释放锁。(其他线程可以调用 对象.notify() 唤醒该线程重新参与到锁的竞争，并执行后续语句)
- 不释放锁的情况:
    - Thread.sleep()、Thread.yield()不会释放锁
    - A线程正在执行同步代码块，如果其他线程改用了A线程的suspend()方法将A线程挂起(只是将A线程从Running状态转化为Ready状态)，此时A线程仍不会释放锁。

### 12、显式定义同步锁
- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问, 每次只能有一个线程对Lock对象加锁, 线程开始访问共享资源前应先获得Lock对象。
- ReentrantLock类实现了Lock接口, 他拥有与synchronized相同的并发性和内存语义, 在实现线程安全的控制中, 比较常用的是ReentrantLock。
- Lock只能锁代码块

### 13、线程协作
- synchronized可以阻止并发更新同一个共享资源, 实现了同步, 但不能实现不同线程之间的通信。
- 为了实现线程的通信我们可以采用以下方式:
    - Object.wait() / wait(long time): 线程等待,直到其他线程通知, 与sleep不同, wait会释放锁.
    - Object.notify() / notifyAll() : 唤醒同一个对象上所有调用wait()方法的进程, 优先级高的进程先被调用。

- 应用场景: 生产者消费者模型
    - 假设仓库只能存放固定数量的产品, 生产者负责将生产出的产品放入仓库, 消费者负责从仓库中取走产品。
    - 如果仓库中没有产品, 则生产者将产品放入仓库, 否则(仓库中有产品)停止生产, 直到仓库中的产品被消费者取走为止。
    - 如果仓库中有产品, 则消费者将取走仓库中的产品, 否则(仓库中没有产品)停止消费并等待, 直到仓库中再次有产品为止。
- 解决方式1——管程法: 生产者负责生产数据的模块, 消费者负责处理数据的模块, 但消费者不能直接使用生产者的数据, 他们之间有一个缓冲区。
    - 此时 Object.wait() 会放在while循环内部，因为.notify() / notifyAll()将会唤醒所有被等待的对象。
- 解决方式2——标志法: 采用一个标志符, 通过标志符来判断当前线程的启动与等待。










