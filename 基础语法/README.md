# 基础语法
本章将介绍java的一些基础语法与基础知识，包括有java的基本数据结构，面向对象编程的基本思路

## 第一章节: 基本数据类型以及变量介绍(Chapter1)
### 1、数据类型和运算符的介绍
- java常见的数据类型包括整数类型、浮点数、单字符、bool类型、字符串类型(不属于基本数据类型)
- 整数:
    - 二进制0b开头, 八进制0开头, 十六进制0x开头
    - 包含有byte、short、int、long四种类型，每种类型的位宽长度从低到高为8到64
    - 注意在long类型定义时需要在末尾加上l
    - 整数常量默认是int类型, 所以short = short + 1会报错, 因为1是int的(但使用short += 1则不会报错)
        - byte n = 10不会报错是因为: 将具体数值给byte时会先判断该数是否在byte的范围内，如果在则可以赋值。如果是按变量之间相互赋值则会直接判断类型
- 浮点数:
    - 包含有float、double两种类型，其中从低到高是32、64位宽
    - float定义时需要在数字末尾加上f，因为默认的小数是double类型
- 单字符(16位宽)采用单引号''，字符串采用双引号""
- 注意：
    - 低位与高位运算会自动往高位转换，但低位与低位运算会出现内存溢出
    - 从高位要转化为低位类型，我们需要使用**强制类型转换**: 低位数据类型 a = (高位数据类型) b
    - 注意浮点数计算后的陷进，浮点数计算后是一个估计值不能直接使用==进行相等比较(直接定义是可以的)
    - 在不同数据类型的混合运算中，会计算出最大的数据类型，将所有的数据转换为最大的。
    - byte/short不能自动转换为char，所以不能将byte/short变量赋值给char变量。
    - byte、short、char可以进行运算，在运算(单种运算/混合运算)时会将所有数值变为int

### 2、变量定义介绍
- 变量定义: 数据类型 变量名 [= value]; 可以在定义时同时赋值，也可以不赋值，如果不赋值则系统自动赋值null(数字类型默认赋值0)
- 常量定义: final 数据类型 常量名 [= value];

### 3、基本数据类型与String类对象的转化
- 基本数据类型转换为String类型可以使用+""的方式即可，如果+两边出现string类型，则+改变为连接字符串的符号，否则视为数字加法。如果有多个+则从左往右运算, 直到知碰到string类型变为字符串连接符
- String类型转化为基本数据类型需要调用基本数据类型对应的.parsexxx(String)方法
    - Integer.parseInt(String)
    - Double.parseDouble(String)int
    - Float.parseFloat(String)
    - Long.parseLong(String)
    - Byte.parseByte(String)
    - Boolean.parseBoolean(String)
    - Short.parseShort(String)
    - 字符串转为char的操作是将字符串中的某个字符取出来，String.charAt(index)
- 注意：
    - 将String转化为基本数据类型时需要保证转化后的有效数据，"hollow"不能转化为int

## 第二章节: 运算符介绍以及二进制计算细节(Chapter2)
### 4、运算符
- 算数运算符号: +、-、*、/、%(取余)、++(自增)、--(自减)
    - a%b(取余)的本质是: a - ( (int)a / b * b);
    - ++/--表示自增/自减，独立使用时a++(++a)本质是a = a + 1; 非独立使用时，++a表示a先+1再参与其他运算, a++表示a先参与其他运算再+1；需要注意到的是自增在参与运算时底层其实是利用了临时变量的，++a的执行顺序是(1)a = a + 1 (2)temp = a (3)temp参与其他运算；a++的执行顺序是(1)temp = a (2)a = a + 1 (3)temp参与其他运算
- 关系运算符号: <、>、>=、<=
- 逻辑运算符: 短路或:||  短路与:&&  非:!  逻辑或:|  逻辑与:&  异或:^(不同为真,相同为假)
    - 短路或/短路与 表示如果第一个表达式的结果已经能得到逻辑结果，那么将不会执行第二个表达式
- 逻辑运算符: 逻辑或:|  逻辑与:&  异或:^(不同为真,相同为假)
    - 上述运算符可以对二进制数值进行操作
- 赋值运算符号: +=, -=, *=, /=
    - 赋值运算符号隐藏了强制类型转换，比如byte b=1, b+=1, 得到的结果b=2且b仍为byte类型
- 三元运算符: x ? y : z  表示如果x=true则结果为y, 否则结果为z
    - 三元运算符如果需要将返回值进行赋值，需要保证返回值和接受变量类型匹配
    
### 5、键盘输入语句
- Scanner类属于java.util这个包，可以通过import java.util.Scanner导入该类。
- 创建new Scanner(System.in,"UTF-8")对象，其中"UTF-8"表示将System.in的获取到的字节，根据UTF-8字符集转化为字符。(此处需要保证输入字符编码模式需要对应上UTF-8)

### 6、进制
- 二进制: 0B/0b开头，例如：0b1010
- 八进制: 0开头，例如：0172
- 十六进制：0x开头，例如：0x10ac
- 其他进制转十进制：从最低位开始，将每个位上的数提取出来，乘以2/8/16的(位数-1)次方，然后求和。
- 十进制转其他进制：将十进制的数不断除以2/8/16，直到商为0，将每一步的余数倒过来书写即可。
- 二进制转八、十六进制: 从低位开始每3/4位一组，转化十进制数，这些数就是为8/16进制数了。
- 八、十六进制转二进制: 将每一位数转为对应的3/4位的二进制数即可。
- 位运算：<<(向左位移)、>>(向右位移)、~(取反)、^(按位异或)、|(按位或)、&(按位与)；
    - 算数左移<<: 符号位不变，低位补0
    - 算数右移>>: 低位舍去，符号位不变，用符号位补溢出高位
    - 无符号右移>>>: 低位溢出，高位补0，不处理符号位，符号位跟着移动
    - 向左位移几位就是*几个2，右移动就是/(注意是/就是求商不要余数的意思)
    - ^不同为真,相同为假
- 原码、反码、补码：(重点)
    - 二进制的最高位表示符号：0表示＋，1表示-
    - 正数的原码，反码，补码都一样(三码合一)
    - 负数的反码=原码符号位不变(1)，其他位取反(0变1，1变0)
    - 负数的补码=负数的反码+1，负数的反码=负数的补码-1
    - 0的反码，补码都是0
    - java的数都是有符号的
    - 计算机运算的时候，都是以**补码**的方式来运算的
    - 看运算结果的时候，要看他的**原码**

## 第三章节: 控制结构(Chapter3)
### 7、分支控制(if else switch)
- 单分支(if) 双分支(if else) 多分支(if else if else if)
- switch分支结构，表达式，case 常量，当表达式=常量时执行对应代码块
    - 在每个case中最好都加上一个break，否则会直接执行后续case中的语句块代码，并且并不会判断后续case是否成立(穿透现象)
    - 表达式 的数据类型应当与常量的类型一致， 或者可以自动转换为可以相互比较的类型
    - 表达式中的返回值只可以是以下类型: byte、short、int、char、enum(枚举)、String
    - case中的值必须是常量或者常量表达式(2+3), 不能是变量
### 8、循环控制
- for循环控制可以将循环变量的定义放在循环体外(这样循环体外也可以获取循环变量)；循环变量改变也可以放在循环体内部，不过主要for(;;)中分号不可省略；for(;;i++,j++),在循环变量的迭代部分可以同时对多个变量迭代。
- while循环：循环变量在外部定义，循环变量的迭代在循环体内部
- do{}while(); 先执行后判断，至少执行一次
- break语句的细节：
    - 当break出现在多层嵌套的语句块中时可以通过标签指明要终止的那一层语句
    - 如果没有指定标签，则break是跳出最近一层循环体.
- continue语句的细节:
    - continue在多层嵌套的语句块中时也可以使用标签，之明回到那一层的继续循环
    - 如果没有指定标签，则continue是继续最近一层循环体.

## 第四章节: 数组、排序、查找(Chapter4)
### 9、数组
- 数组(引用数据类型): 将多个同一类型的数据放在一起
    - 数组定义一(静态初始化): 变量类型[] 变量名 = {值1，值2}; 定义数组同时给定值, 其中[]也可以挪到变量名后边
    - 数组定义二(动态初始化): 变量类型[] 变量名; 变量名 = new 变量类型\[数组长度]; 声明数组，创建数组长度(分配空间)
        - 变量名\[下标] = 值；采用这种方式给数组中每个位置赋值。
        - 动态初始化中可以将声明数组和创建数组长度(分配空间)合并到一起：变量类型[] 变量名 = new 变量类型\[数组长度]
- 注意事项:
    - 数组中的数值需要与数值声明的类型一致，或者是可以进行自动类型转换的类型。
    - 数组中也可以放引用数据类型(对象)
    - 数组创建后如果没有赋值，则有默认值: boolean-false, String-null, int-0, char-\u0000
    - 数组下标从0开始,下标最大值是长度-1
    - 数组型数据本质是对象
- 数组赋值机制
    - 数组的赋值方式为引用传递 arr1 = arr2 传递的是arr2的地址
- 数组扩容:
    - 创建一个新数组，长度为原来数组长度+1，将原来数组赋值给新数组，将增加的元素赋值给新数组的最后一位
    - 将新数组地址赋值给原来变量(没有变量引用旧数组，旧数组地址所在空间会被回收)
- 二维数组的内存形式
    - 在堆中开辟一个一维数组，存放的是地址，每个地址对应的是堆中另一个一维数组，这个一维数组才是真正存放数据的
    - 可以动态分配地址所指向的数据空间大小，int[][] arr = new int\[3][]，此时并没有开辟出存放数据的空间，因此我们可以开辟不同空间大小
        - arr[0] = new int[1]; arr[1] = new int[2] ; arr[2] = new int[3];给每个地址开辟独立的数据空间
    - 在二维数组的静态初始化时也可以根据一维数组的长度不同而不同赋值。





    - Demo7：定义类方法，方法的重载，可变参数定义
    - Demo8：数组的定义与使用
    - Demo9：Arrays类的简单介绍
    - Demo10：类的定义，静态方法(static)、非静态方法的介绍
        - Demo10.java
        - Student.java
    - Demo11：子类，父类的方法调用，继承的介绍
        - Demo11.java
        - Person.java
        - Teacher.java
    - Demo12：方法的重写(覆写)
        - A.java
        - B.java
    - Demo13：多态的介绍
        - Person.java
        - Teacher.java
    - Demo14：抽象类/抽象方法的介绍
    - Demo15：接口
    - Demo16：异常捕获与处理
