# 基础语法
本章将介绍java的一些基础语法与基础知识，包括有java的基本数据结构，面向对象编程的基本思路

## 第一章节: 基本数据类型以及变量介绍 (Chapter1)
### 1、数据类型和运算符的介绍
- java常见的数据类型包括整数类型、浮点数、单字符、bool类型、字符串类型(不属于基本数据类型)
- 整数:
    - 二进制0b开头, 八进制0开头, 十六进制0x开头
    - 包含有byte、short、int、long四种类型，每种类型的位宽长度从低到高为8到64
    - 注意在long类型定义时需要在末尾加上l
    - 整数常量默认是int类型, 所以short = short + 1会报错, 因为1是int的(但使用short += 1则不会报错)
        - byte n = 10不会报错是因为: 将具体数值给byte时会先判断该数是否在byte的范围内，如果在则可以赋值。如果是按变量之间相互赋值则会直接判断类型
- 浮点数:
    - 包含有float、double两种类型，其中从低到高是32、64位宽
    - float定义时需要在数字末尾加上f，因为默认的小数是double类型
- 单字符(16位宽)采用单引号''，字符串采用双引号""
- 注意：
    - 低位与高位运算会自动往高位转换，但低位与低位运算会出现内存溢出
    - 从高位要转化为低位类型，我们需要使用**强制类型转换**: 低位数据类型 a = (高位数据类型) b
    - 注意浮点数计算后的陷进，浮点数计算后是一个估计值不能直接使用==进行相等比较(直接定义是可以的)
    - 在不同数据类型的混合运算中，会计算出最大的数据类型，将所有的数据转换为最大的。
    - byte/short不能自动转换为char，所以不能将byte/short变量赋值给char变量。
    - byte、short、char可以进行运算，在运算(单种运算/混合运算)时会将所有数值变为int

### 2、变量定义介绍
- 变量定义: 数据类型 变量名 [= value]; 可以在定义时同时赋值，也可以不赋值，如果不赋值则系统自动赋值null(数字类型默认赋值0)
- 常量定义: final 数据类型 常量名 [= value];

### 3、基本数据类型与String类对象的转化
- 基本数据类型转换为String类型可以使用+""的方式即可，如果+两边出现string类型，则+改变为连接字符串的符号，否则视为数字加法。如果有多个+则从左往右运算, 直到知碰到string类型变为字符串连接符
- String类型转化为基本数据类型需要调用基本数据类型对应的.parsexxx(String)方法
    - Integer.parseInt(String)
    - Double.parseDouble(String)int
    - Float.parseFloat(String)
    - Long.parseLong(String)
    - Byte.parseByte(String)
    - Boolean.parseBoolean(String)
    - Short.parseShort(String)
    - 字符串转为char的操作是将字符串中的某个字符取出来，String.charAt(index)
- 注意：
    - 将String转化为基本数据类型时需要保证转化后的有效数据，"hollow"不能转化为int

## 第二章节: 运算符介绍以及二进制计算细节 (Chapter2)
### 4、运算符
- 算数运算符号: +、-、*、/、%(取余)、++(自增)、--(自减)
    - a%b(取余)的本质是: a - ( (int)a / b * b);
    - ++/--表示自增/自减，独立使用时a++(++a)本质是a = a + 1; 非独立使用时，++a表示a先+1再参与其他运算, a++表示a先参与其他运算再+1；需要注意到的是自增在参与运算时底层其实是利用了临时变量的，++a的执行顺序是(1)a = a + 1 (2)temp = a (3)temp参与其他运算；a++的执行顺序是(1)temp = a (2)a = a + 1 (3)temp参与其他运算
- 关系运算符号: <、>、>=、<=
- 逻辑运算符: 短路或:||  短路与:&&  非:!  逻辑或:|  逻辑与:&  异或:^(不同为真,相同为假)
    - 短路或/短路与 表示如果第一个表达式的结果已经能得到逻辑结果，那么将不会执行第二个表达式
- 逻辑运算符: 逻辑或:|  逻辑与:&  异或:^(不同为真,相同为假)
    - 上述运算符可以对二进制数值进行操作
- 赋值运算符号: +=, -=, *=, /=
    - 赋值运算符号隐藏了强制类型转换，比如byte b=1, b+=1, 得到的结果b=2且b仍为byte类型
- 三元运算符: x ? y : z  表示如果x=true则结果为y, 否则结果为z
    - 三元运算符如果需要将返回值进行赋值，需要保证返回值和接受变量类型匹配
    
### 5、键盘输入语句
- Scanner类属于java.util这个包，可以通过import java.util.Scanner导入该类。
- 创建new Scanner(System.in,"UTF-8")对象，其中"UTF-8"表示将System.in的获取到的字节，根据UTF-8字符集转化为字符。(此处需要保证输入字符编码模式需要对应上UTF-8)

### 6、进制
- 二进制: 0B/0b开头，例如：0b1010
- 八进制: 0开头，例如：0172
- 十六进制：0x开头，例如：0x10ac
- 其他进制转十进制：从最低位开始，将每个位上的数提取出来，乘以2/8/16的(位数-1)次方，然后求和。
- 十进制转其他进制：将十进制的数不断除以2/8/16，直到商为0，将每一步的余数倒过来书写即可。
- 二进制转八、十六进制: 从低位开始每3/4位一组，转化十进制数，这些数就是为8/16进制数了。
- 八、十六进制转二进制: 将每一位数转为对应的3/4位的二进制数即可。
- 位运算：<<(向左位移)、>>(向右位移)、~(取反)、^(按位异或)、|(按位或)、&(按位与)；
    - 算数左移<<: 符号位不变，低位补0
    - 算数右移>>: 低位舍去，符号位不变，用符号位补溢出高位
    - 无符号右移>>>: 低位溢出，高位补0，不处理符号位，符号位跟着移动
    - 向左位移几位就是*几个2，右移动就是/(注意是/就是求商不要余数的意思)
    - ^不同为真,相同为假
- 原码、反码、补码：(重点)
    - 二进制的最高位表示符号：0表示＋，1表示-
    - 正数的原码，反码，补码都一样(三码合一)
    - 负数的反码=原码符号位不变(1)，其他位取反(0变1，1变0)
    - 负数的补码=负数的反码+1，负数的反码=负数的补码-1
    - 0的反码，补码都是0
    - java的数都是有符号的
    - 计算机运算的时候，都是以**补码**的方式来运算的
    - 看运算结果的时候，要看他的**原码**

## 第三章节: 控制结构 (Chapter3)
### 7、分支控制(if else switch)
- 单分支(if) 双分支(if else) 多分支(if else if else if)
- switch分支结构，表达式，case 常量，当表达式=常量时执行对应代码块
    - 在每个case中最好都加上一个break，否则会直接执行后续case中的语句块代码，并且并不会判断后续case是否成立(穿透现象)
    - 表达式 的数据类型应当与常量的类型一致， 或者可以自动转换为可以相互比较的类型
    - 表达式中的返回值只可以是以下类型: byte、short、int、char、enum(枚举)、String
    - case中的值必须是常量或者常量表达式(2+3), 不能是变量
- 编程思想: 当我们做输入控制时候，先考虑正确情况，再将正确情况取反作为if的条件。我们采用if都是限制不正确的情形，这样可以使用多个if来控制(避免隐藏的条件逃避)
### 8、循环控制
- for循环控制可以将循环变量的定义放在循环体外(这样循环体外也可以获取循环变量)；循环变量改变也可以放在循环体内部，不过主要for(;;)中分号不可省略；for(;;i++,j++),在循环变量的迭代部分可以同时对多个变量迭代。
- while循环：循环变量在外部定义，循环变量的迭代在循环体内部
- do{}while(); 先执行后判断，至少执行一次
- break语句的细节：
    - 当break出现在多层嵌套的语句块中时可以通过标签指明要终止的那一层语句
    - 如果没有指定标签，则break是跳出最近一层循环体.
- continue语句的细节:
    - continue在多层嵌套的语句块中时也可以使用标签，之明回到那一层的继续循环
    - 如果没有指定标签，则continue是继续最近一层循环体.

## 第四章节: 数组、排序、查找 (Chapter4)
### 9、数组
- 数组(引用数据类型): 将多个同一类型的数据放在一起
- 数组定义一(静态初始化): 变量类型[] 变量名 = {值1，值2}; 定义数组同时给定值, 其中[]也可以挪到变量名后边
- 数组定义二(动态初始化): 变量类型[] 变量名; 变量名 = new 变量类型\[数组长度]; 声明数组，创建数组长度(分配空间)
    - 变量名\[下标] = 值；采用这种方式给数组中每个位置赋值。
    - 动态初始化中可以将声明数组和创建数组长度(分配空间)合并到一起：变量类型[] 变量名 = new 变量类型\[数组长度]
- 注意事项:
    - 数组中的数值需要与数值声明的类型一致，或者是可以进行自动类型转换的类型。
    - 数组中也可以放引用数据类型(对象)
    - 数组创建后如果没有赋值，则有默认值: boolean-false, String-null, int-0, char-\u0000
    - 数组下标从0开始,下标最大值是长度-1
    - 数组型数据本质是对象
- 数组赋值机制
    - 数组的赋值方式为引用传递 arr1 = arr2 传递的是arr2的地址
- 数组扩容:
    - 创建一个新数组，长度为原来数组长度+1，将原来数组赋值给新数组，将增加的元素赋值给新数组的最后一位
    - 将新数组地址赋值给原来变量(没有变量引用旧数组，旧数组地址所在空间会被回收)
- 二维数组的内存形式
    - 在堆中开辟一个一维数组，存放的是地址，每个地址对应的是堆中另一个一维数组，这个一维数组才是真正存放数据的
    - 可以动态分配地址所指向的数据空间大小，int[][] arr = new int\[3][]，此时并没有开辟出存放数据的空间，因此我们可以开辟不同空间大小
        - arr[0] = new int[1]; arr[1] = new int[2] ; arr[2] = new int[3];给每个地址开辟独立的数据空间
    - 在二维数组的静态初始化时也可以根据一维数组的长度不同而不同赋值。

## 第五章节: 类、对象、方法 (Chapter5)
### 10、类
- 通过class可以创建出一个对象，在对象中可以定义需要的属性，通过Cat 变量名 = new Cat()创建对象；我们也可以先声明再new，当我们new的时候才会在**堆**中开辟数据空间,并得到地址。
- Java内存结构介绍：
    - 栈：一般存放局部变量，基本数据类型
    - 堆：存放对象的数据空间(数组，引用类型)
    - 方法区：常量池(存放常量,比如字符串)，类的加载信息
    - 类信息在**方法区**只会加载一次
- 对象的内存布局: 
    - 对象的本质是引用类型
    - 在创建对象时会在**栈**创建一个地址，对象名指向这个地址；该地址是**堆**中开辟的一个数据空间，这个数据空间存放的是对象所拥有的属性数据(因此说真正的对象其实是在**堆**中)，如果属性的类型是字符串(引用类型)则**堆**中存储的就是地址，如果属性的类型是基本数据类型则**堆**中存储的就是真实数据了；如果**堆**中存储的是地址，则该地址就是指向真实数据位置。
    - 在new Cat()的时候**方法区**中常量池里将会加载Cat的信息包括有1、属性信息。2、方法信息
- 属性: 也被成为成员变量，一个类的属性可以是基本数据类型，也可以是引用类型(数组，对象)
    - 属性的定义: 访问修饰符(控制属性的访问范围public、private、protected) 属性类型 属性名
    - 属性没有赋值则会存在默认值: boolean-false, 引用类型-null, int-0, char-\u0000

### 11、对象
- 对象在new的时候，会在**堆**中开辟一个数据空间存放的对象所拥有的属性的地址/真实数据，并返回该空间的地址到**栈**中，对象名在栈中指向这个地址。此时在**堆**中的那个数据空间里都是默认值(null, 0)，当使用“对象.属性 = xxx”赋值时,**堆**中数据空间的数据会更新
- p2 = p1：是赋值的是**栈**中的地址，换句话说p2指向的**堆**的数据空间和p1是一样的，因此改变p2和p1其实就是同一个对象。(跟数组一样)

### 12、方法
- 方法的调用机制：p1.getSum(12,10)
    - 当执行getSum方法时会在**栈**中再开辟一个独立的空间，在这个独立空间里会将12赋值给n1，10赋值给n2(注意由于实参是一个基本数据类型所以此处的赋值是真实赋值，如果是引用类型此处的赋值其实是赋值的是**堆**中的地址)
    - 当执行到return时，会将结果返回给**main栈**中对应位置，并退出这个**独立栈空间**。
- 方法只能返回一个值，但我们可以返回一个数组，数组里放多个数据的结果。
- 如果方法定义时void没有返回值，我们可以return，也可以不用return, 但需要保证没有return后没有东西。
- 方法体中不能再定义方法。
- 同一个类中可以互相调用，不用使用对象.方法名的方式。
- 方法的传参机制：
    - 对于基本数据类型，传递的是值拷贝，形参的任何变化不影响实参！
    - 对于引用类型(数组)的传递，传递的是地址(真正的数据仍在**堆**中)，因此形参的变化会影响实参！
- 拷贝一个对象我们可以在方法中新生成一个对象，将属性进行从新赋值，要注意的是此时的赋值也遵循着：基本类型值拷贝，引用类型传递地址。(具体案例参看Object01.java)
- 递归中需要注意的事项：
    - 如果在递归中传递的是引用类型，就会共用该对象
    - 递归必须无线向递归条件逼近，否则会报错StackOverflowError
- 方法的重载：允许同一个类中，多个同名方法的存在，但要求形参的列表要不同
    - 形参个数,类型,类型顺序不同即为重载(至少有一个不同)
    - 对返回类型没有要求
    - 发生自动转换才能匹配上形参的方法 比 直接匹配上形参的方法 调用优先级低
- 可变参数：同名同功能但参数个数不同的方法，封装成一个方法
    - 可变参数的实参可以直接是数组。
    - 一个方法中只能指定一个可变参数, 并且可变参数必须在普通参数最后。
- 作用域
    - 局部变量: 成员方法中定义的变量，代码块(用{}来)中定义的变量
    - 局部变量只能在定义它的代码块中才能使用
    - 全局变量(属性变量)可以在整个类中都可以使用这个属性。
    - 全局变量(属性)可以不赋值即可使用，因为有默认值
    - 局部变量必须赋值后才能使用，因为默认值
    - 属性和局部变量可以重名，具体使用时会遵循就近原则
    - 在一个作用域的中局部变量不可以重名，不同的作用域中可以重名
    - 注意事项:
        - 属性可以通过对象调用在其他属性中访问到; 而局部变量只有在定义它的代码块中使用，其他地方不能被使用
        - 属性的声明周期长，随着属性的销毁而销毁；局部变量在代码块执行完毕即销毁
        - 局部变量不可以加 修饰符(public...)
- 构造器
    - 构造器的修饰符可以是public, private, protected, 默认
    - 构造器名称必须与类名保持一致，构造器没有返回值, 也不能写void!
    - 构造器的调用由系统完成，构造器的主要作用是对新对象的初始化.
    - 注意事项
        - 一个类可以定义多个构造器(构造器的重载)
        - 如果一个类没有定义构造器，则系统会默认无参构造器(使用javap指令可以对.class文件进行反编译)
        ```
        Dog(){

        }
        ```
        - 一但定义了构造器则不会再使用无参构造器了(即不能再使用new Person1()进行对象定义)，除非自己再定义一个无参构造器 
    - 对象创建内存分析：
        - 第一步: 将类信息加载到**方法区**
        - 第二步: 在**堆**中开辟空间，将属性初始化为默认值
        - 第三步: 如果属性有定义值则将定义的值赋予属性
        - 第四步: 如果存在构造器，则执行构造器内容
        - 第五步: 将**堆**中对象的地址赋给**栈**中的对象名变量(对象的引用)。完成
- this关键字
    - java虚拟机会给每个对象分配this，代表的是当前对象。
    - this.name表明的就是当前类的属性name, 这样可以在构造器中定义和属性名相同的局部变量名
    - 在**堆**中创建的每个对象都存在一个隐藏属性叫做this，这个this是指向的对象本身在**堆**的地址。(这个this在对象在堆中创建时就会被创建)
    - 注意事项:
        - this可以访问本类的属性、方法、构造器
        - this想调用构造器则只能在构造器中调用另一种构造器, this(参数列表)。并且有this访问构造器的语法，则必须放在第一条语句，且只能用一个this(参数列表)
        - this只能在类的方法中使用


## 第六章节: 面向对象编程 (Chapter6)
### 13、包介绍
- 区分相同名字的类、当类有很多时可以很好的管理类、控制访问范围
- 本质: 创建不同的文件夹保存类文件
- 使用: package 包名: 表明当前类是在那个包下，表示打包，将下面写的类打包
- 包的命名规范: 
    - 不能以数字开头, 不能是关键字/保留字
    - com.公司名.项目名.模块名(例如: com.sina.crm.user)
- 常用的包:
    - java.lang.*: 基本包不需要import导入,可以直接使用
    - java.util.*: 系统提供的工具包, 工具类，例如Scanner
    - java.net.*: 网络开发
    - java.awt.*: 界面开发, GUI
- 导入包的方式:
    - import 包名.类名 : 只引入包中的单独一个类
    - import 包名.*   : 导入包中的所有类
- 包的注意事项:
    - package的作用是声明当前类所在的包，需要放在class的最上面, 一个类中最多只有一句package
    - 需要注意编译时需要在顶层目录下

### 14、访问修饰符
- 用于控制方法和属性的访问权限和范围
    - 公开级别public: 对外公开
    - 受保护protected: 对子类或同一个包中的类公开
    - 默认级别: 向同一个包的类公开
    - 私有级别Private: 只有类的内部可以使用
- 注意: 类的访问修饰符只有两个。默认 和 public

### 15、封装
- 把抽象出的数据(属性)和对数据(属性)的操作(方法)封装在一起，数据被保护在内部，程序的其他部分只有通过授权的操作(方法)，才能对数据进行操作
- 封装实现的步骤:
    - 先将属性私有化private
    - 提供一个public方法 set : 用于对属性的判断并赋值。在这个方法中加入数据验证的业务逻辑
    - 提供一个public方法 get : 用于获取某个属性的值。在这个方法中可以加入权限的验证
- 将构造器与set方法相结合。在构造方法中调用set方法

### 16、继承
- 当两个类的属性和方法有很多是相同的，此时代码为提高代码复用性，我们可以使用**继承**的特性
- 例如B类和C类有很多的属性和方法一致，我们可以创建一个A类，在A类中写好BC类共有的方法。在B,C类中使用extends关键字继承A类中的属性和方法
- protected 修饰的方法和属性 可以被不同包的子类访问(注意此处是被子类访问，而不是通过子类对象访问)
- 父类通过开放public方法类访问私有属性。这个public方法可以被子类继承，从而可以通过子类对象也可以访问到这个方法。
- 细节：
    - 子类继承了所有的**非私有**的属性和方法，非私有的属性和方法可以**在子类直接访问**(在子类直接访问 != 通过子类对象访问)
    - 子类必须调用父类的构造器，完成父类的初始化。(默认的时候，子类任意的构造器都会调用父类的无参构造器，super()会被默认放在子类构造器的第一步)，注意如果子类构造器中的第一句是this(...)那么只会执行this而不会执行super了，因为this()和super()都是在第一位。
    - 如果父类不存在无参构造器，则在子类的每个构造器第一句都必须指定使用super(参数列表)来指定父类的哪个有参构造。有父才有子
    - 我可以显式的调用父类构造器，使用super(参数列表)，此时不会再调用super(), 父类构造器只能调用一个。
    - super()必须放在子类构造器的第一行。注意此时也与this()冲突了，因为this也必须放在第一行。所以this和super不能共存
    - Object是所有类的父类。
    - 父类构造器的调用不限于直接父类，可以追溯到顶级父类Object
    - 一个类只能直接继承一个父类(即只能extend 1个类)
- 继承的本质: 当子类对象建立后，实质上是建立了查找关系。
    - 第一步: 当子类对象被创建的时候，在方法区会依次加载顶级父类-...-直接父类-子类的类信息
    - 第二步: 在**堆**中开辟子类对象空间，并且将顶级父类至直接父类的属性分别在开辟空间中存储(即使属性名相同但仍可以加载，因为每个等级父类的父类都会开辟独立的空间存储该父类的属性和方法), 总的来说就是每个等级的父类都在执行对象开辟的第一至第三步,在单独空间中。
    - 当我们通过子类对象访问某个属性时，会根据就近原则先查找子类中是否有该属性且可以访问，如果有则返回。如果没有则向上查找直接父类中是否存在该属性且可以访问，如果还没有找到则继续向上查找间接父类....直到找到顶级父类Object，都没有找到可以访问的该属性，则报错。在查找过程中只要有一个类中找到了该属性，但属性不可访问则也会直接报错(不可访问不会继续向上找了。)
- super关键字: 用于访问父类的属性、方法、构造器(前面已经提到过了)
    - super.属性名: 访问父类的属性，但不能访问父类的private属性(默认权限的属性也无法在其他包访问到)
    - super(): 调用父类构造器，只能放在子类构造器中的第一句位置，其他位置步可以
    - super.方法名(): 调用父类的方法，但不能调用父类的private方法，外包子类无法调用默认权限的方法。
    - 如果父类和子类的属性名或方法名重复，需要使用super.或者this.来明确指代调用的父类或者子类的方法或属性。如果没有指代，则查找方法根据就近原则(跟内存找属性是一个意思)
    - 注意: 使用super.方法名()/super.属性名，则会跳过查找本类的方法/属性, 直接从父类查找开始，后续查找流程是不变。
- this和super的区别就是确定开始查找的起始点，this的起始点是本类开始查找，super的起始点是父类开始查找(跳过子类)，查找的原则都是就近原则(直到找到最近父类存在，如果中途出现权限不足则直接中断查找，报错)

### 17、方法重写/覆盖(override)
- 子类有一个方法和父类的某个方法的名字、返回类型、参数列表都"一样"，则我们说子类这个方法覆盖了父类的方法。
- 注意事项:
    - 子类重写父类方法必须保证: 参数列表、方法名完全相同，子类的返回类型和父类的返回类型一致或者父类返回类型是子类返回类型的父类(例如父类返回类型是Object，则子类的返回类型可以是Object的子类即可) (父类的返回类型一定要兼容子类)
    - 子类方法不能缩小父类的访问权限: public > protected > 默认 > private。可以增大。
- 重写和重载的区别
    - 重载一般发生在本类，重写一般发生在子-父类
    - 方法名都必须一样
    - 重载的参数列表类型，个数，顺序至少有一个不同；重写必须相同
    - 重载对返回类型没有要求；重写时子类返回类型需要和父类相同或者是父类返回类型的子类
    - 重载对修饰符没有要求，重写时子类修饰符不能比父类修饰符的范围小(可以大)

### 18、多态
- 情景：主人(类)给宠物(类)用食物(类)喂食(feed方法)，feed方法中我们需要根据不同宠物喂食不同食物。例如:我们需要给猫(宠物子类)喂食鱼肉(食物子类)，我们需要给狗(宠物子类)喂食骨头(食物子类)，那么在写feed方法时我们需要写如下代码:
```
// 给狗喂食骨头
public void feed(Dog dog, Bone bone){
    ...
}

// 给猫喂食鱼肉
public void feed(Cat cat, Fish fish){
    ...
}

// 如果需要给其他动物(宠物的子类)，喂食其他的食物(食物的子类)
public void feed(... , ...){
    ...
}
```
从上述情境中我们可以看到，当更换了不同的食物子类或者宠物子类时，我们都需要重写一个feed方法，这显然是不利于维护的，因此引出了多态。
- 多态: 方法和对象具有多种形态
- 方法的多态
    - 方法的重载是典型的例子。传入不同的参数，就会调用不同的say()方法，体现了say()的多种形态。
    - 方法的重写是典型的例子。调用say()方法会自行定位调用的子类方法和父类方法
- 对象的多态
    - **重要总结**: 
        - 一个对象的编译类型和运行类型可以不一致(可以让父类的引用指向子类的对象 Animal an = new Dog(), an是在**栈**中的一个对象的引用，存放的是真实对象的地址。而真实对象是在**堆**中是一个Dog类。此时an的编译类型是Animal，运行类型是Dog)
        - 编译类型在定义对象时就确定了，不能更改。运行类型是可以变化的(an = new Cat(), 此时的运行类型变成了Cat, 编译类型仍然是Animal, an此时指想的是**堆**中Cat对象了)
        - 编译类型看定义时 = 的左边，运行类型看 = 号右边。
        - 执行时，看运行类型。编译类型是约束，执行类型是行为，所有的行为都需要在约束中。
- 多态的细节
    - 多态前提:两个对象(类)存在继承关系
    - 向上转型:父类的引用指向了子类对象(例如:Animal an = new Dog()); 
        - 父类类型 引用名 = new 子类类型(); 此处的父类可以是直接父类也可以是简介父类。
        - 特点: 可以调用父类中的所有成员(需要遵循访问权限); 不能调用子类中特有的方法。因为在编译阶段(javac)能调用那些方法/成员属性是由编译类型决定的
        - 如果在编译阶段可以找到能调用的方法名, 最终方法的实现效果是看子类(运行类型)的具体实现，因能调用到的方法要么是只有父类有的，要么就是子类重写了的。(注意这里只针对方法，如果是属性则以编译类型定)
    - 向下转型: 将父类引用(an)强制转换为子类引用(子类类型 引用名 = (子类类型) 父类引用)
        - 只能强制转换父类的引用，不能强制转化父类的对象(对象始终储存在**堆**中)。
        - 当前父类的引用必须指向的是当前目标类型的对象.
        - 当向下转型后，可以调用子类中所有代码了
    - 属性没有重写的说法，属性的值看**编译类型**。(如果子类和父类具有同名属性name，如果向上转型后, 父类引用an指向子类对象, an.name返回的将是父类的name)。【属性运行结果看编译类型, 方法运行结果看运行类型, 因为属性没有动态绑定机制】
    - istanceOf比较操作符: 用于判断对象的类型是否为xx类型，也可以判断是否为xx类型的子类型
        - 此处判断的对象类型是指**运行类型**。
        - "a == b" 判断引用类型时判断的是引用a和引用b指向的地址是否相同
- **动态绑定机制**
    - 当对象调用方法时, 所有方法(无论那个位置的方法)会和该对象的**运行类型**(也就内存地址)绑定，也就是说所有的方法的调用都是从**运行类型**的类开始查找方法。
    - 属性**没有动态绑定机制**, 即哪里申明哪里使用, 在当前类查找(根据就近原则查找即可)
- 多态的应用:
    - 多态数组
        - 以父类类型创建数组对象，将子类放入该数组中
        - 每个元素的编译类型是父类型，运行类型是子类型
    - 多态参数
        - 方法定义的形参定义的是父类类型，输入的实参是子类类型

### 19、Object类详解
- Object是所有类的超类。因此其拥有的方式能够被所有类使用
- "==" 和 equals()的区别
    - == 是比较运算符号，既可以判断基本类型(判断值是否相等，无论数据类型是否一致，例如'A'==65)，又可以判断引用类型(判断该引用指向的地址是否相等，即判断是否指向同一个对象).注意无论编译类型是否相同，只判断**堆**中的地址是否相同
    - equals(Object)是Object类的一个方法，只能用于判断引用类型是否相等。通过查看原码可以知道Object的equals其实就是使用==来判断地址是否相等。因此我们一般常用的子类String/Integer都会重写equals。
- hashCode(): 返回对象的哈希码值
    - hashCode()这个方法是为了提高具有哈希结构的容器的效率
    - 两个引用变量执行的是同一个变量，则哈希值是一样的。否则会不一样(不严谨的说)
    - 哈希值是根据地址来计算的，但是哈希值不能等价视为地址。
    - 在集合中，如果hashCode需要的话，常常会重写该方法
- toString(): 返回该对象的字符串表示。Object默认的返回是 全类名 + @ + hashCode的十六进制表示
    - 重写toString方法一般会输出对象属性。
    - 如果直接输出对象，则toString方法会被默认调用
- finalize(): 当垃圾回收器确定该对象没有引用时，系统会自动调用该对象的finalize方法。子类可以重写该方法做一些释放资源的操作。
    - 当某个对象被视为垃圾(该对象没有引用), 在释放该对象的空间之前，会调用对象的该方法。
    - 不是当对象变为垃圾时，就会立刻被回收。垃圾回收机制是由系统来决定的，可以通过System.gc()提前调用。

## 第七章节: 面向对象编程(高级) (Chapter7)
### 20、类变量(静态变量)与类方法(静态方法)
- 类变量：所有对象实例都共享的变量, 与类绑定，因此同一个类的所有对象都可以访问到。可以通过: 对象实例.变量名 或者 类名.变量进行访问。
- 类变量内存布局:
    - jdk8.0版本之后: 类变量会在**堆**中自行开辟出一个空间，每个对象实例化的时候，都会指向这个类变量所在空间，同一个类的所有对象都会指向这同一个类变量空间。
    - jdk8.0版本之前: 类变量(静态变量)在加载类信息时就会在**方法区**开辟空间,与类加载同时发生
    - 注意类变量(静态变量)是在类加载时就会开辟出空间
- 类变量细节: 访问修饰符 static 数据类型 变量名.
    - 类变量遵守的访问权限与普通变量遵守的访问权限一样
    - 类变量在类加载时就完成初始化了，类变量的生命周期随着类的加载而生成
- 类方法: 只需要在方法返回类型之前加入static即可
    - 可以通过类.方法() / 对象名.方法()来调用
    - 类方法中可以无法使用非静态方法和属性(非静态方法和属性是跟随着类实例化的对象的，而类方法是在实例化对象前就已经存在的，因此类方法中无法使用非静态的属性和方法)
    - 父类静态方法无法被子类重写, 但可以被继承使用。
    - 静态方法不存在动态绑定(类似于属性)，跟随着**编译类型**而定。(不存在多态的概念)
- 适用场景: 当方法中不涉及到对象的内容，常见在Utils工具类
- 类方法细节: 
    - 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区。类方法中无法使用this(普通方法中隐含有this)
    - 类方法中不允许使用和对象有关的关键字，比如this,super
    - 类方法(静态方法)中只能访问 静态变量 和 静态方法
    - 普通方法 可以访问 静态成员(静态方法/静态变量)
    
### 21、main()方法详解
- java中虚拟机会调用类的main()方法，所以该方法的访问权限必须是public(java虚拟机根本不在同一个包中)
- java虚拟机调用main()方法时不必常见对象，因此main()方法必须是static
- main()方法接收String类型的数组参数, 该String[]数组中保存执行java命令时传递给所运行的类的参数。(当命令行中使用java 运行类名 参数1 参数2 参数3 ，此时这些参数将会传入main()方法中用字符串数组args接收储存)
- 细节:
    - main()本身是静态方法, 因此main方法中可以访问本类的静态成员，但不能访问本类的非静态成员(必须实例化后使用)

### 22、代码块使用
- 代码块又称为初始化块，属于类中的成员【即类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。但代码块没有方法名，没有返回，没有参数，只有方法体, 不能通过对象或者类名来显示调用。只有在加载类时或创建对象时隐式调用。
- 基本语法:
```
[static] {
    代码逻辑
}
```
- 语法解释
    - 代码块的修饰符只有一个static，可选。有static的叫静态代码块，没有static的叫普通代码块
    - 末尾分号可有可无
- 理解：
    - 代码块可以理解为另一种形式的构造器,可以做初始化的操作
    - 应用场景: 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性。
    - 代码块调用的会先于构造器的调用
- 细节:
    - 静态代码块是对类进行初始化，它随着**类的加载**而执行，并且只会执行一次; 如果是普通代码块, 每创建一个对象就会执行一次。具有继承关系的类，会先加载父类(与此同时父类的静态代码块会先执行)
    - **类的加载时间**
        - 创建对象实例时(new)会加载
        - 创建子类对象实例时，父类也会加载
        - 使用类的静态成员时(方法/属性), 也会加载
    - static跟随类走，非static跟随对象走
    - 构造器的最前面其实是隐藏了 **super()** 和 **调用普通代码块/普通属性初始化**; 而静态相关的代码块/属性，是再类加载时就执行完毕了，是最高优先级
    - 创建对象时，在**一个类**中的调用顺序: (**重点**)
        - 第一步: 调用静态代码块和静态属性初始化(静态代码块和静态属性初始化优先级一样, 如果有多个静态代码块和多个静态变量初始化则按照定义的顺序调用)
        - 第二步: 调用普通代码块和普通属性的初始化(这俩优先级一样，按顺序调用)
        - 第三步: 执行构造器内部其他内容
    - 创建对象时，包含有继承关系的类中调用顺序: (**重点**)
        - 第一步: 最高级父类静态代码块/静态属性初始化(优先级一致，按顺序执行)——>最低级的父类执行完毕
        - 第二步: 子类的静态代码块/静态属性初始化(优先级一致，按顺序执行)
        - 第三步: 最高级父类的普通代码块/普通属性初始化(优先级一致，按顺序执行)
        - 第四步: 最高级的父类构造方法, 加载完毕后执行次高级父类的第三步+第四步。直到最低级父类的第四步执行完毕。
        - 第五步: 子类的普通代码块/普通属性初始化(优先级一致)
        - 第六步: 子类的构造方法其他部分
    - 总结: 先静态(类加载信息同时会执行静态, 类信息的加载是先顶级)，再super()，再普通，最后再构造

### 23、设计模式一: 单例模式
- 某个类中只能存在一个实例对象，无法通过new的方法建立多个实例对象。该实例对象与类绑定。
- 步骤如下:
    - 1) 构造器私有化(使得无法通过new来创建对象)
    - 2) 在类中创建对象
    - 3) 向外暴露一个公共方法，将类中创建的对象地址传递出去.getInstance
- 饿汉模式 / 懒汉模式 的区别
    - 二者主要区别在于创建对象的时机不同: 饿汉式在类的加载时就创建了对象，懒汉式在使用时才会创建实例
    - 饿汉模式不存在线程安全问题，懒汉模式由于是调用方法创建的对象因此会存在线程安全问题
    - 饿汉模式存在浪费资源的可能，懒汉模式不存在这个问题。

### 24、final关键字介绍
- final: 最终的，最后的。可以修饰类、属性、方法、局部变量
- final的作用: 
    - final 类: 该类无法被继承。(没有子类)
    - final 方法: 该方法无法被子类重写
    - final 属性: 该属性无法被修改(无论是子类还是本类都无法修改)。如果是修饰引用类型的对象，则表明该属性的地址不能修改，即必须一直指向同一个对象地址空间，但对象中成员可以改变。
    - final 局部变量: 局部变量无法被修改 
- 细节:
    - final修饰的属性又叫做**常量**，一般用 大写字母_大写字母 表示
    - final修饰非静态属性时有且仅有三种赋初值方法(只能选取一种方式)
        - (1) 在定义时给定初值
        - (2) 在构造器中给定初值
        - (3) 在非静态代码块中给定初值
    - final修饰静态属性时有且仅有两种赋初值方法 (也需要遵守静态成员的规则)
        - (1) 在静态属性定义时赋初值
        - (2) 在静态代码块中赋初值
    - final类不能被继承，但可以实例化对象
    - final方法不能被重写，但可以被继承使用
    - final不能修饰构造方法
    - final 与 static 如果搭配使用效率更高，因为不会导致类的加载。(不会导致其他的静态代码块, 静态方法的加载)
    - 包装类(Integer, Double, Float, Boolean)都是final类

### 25、抽象类-abstract关键字
- 父类方法不确定性: 当父类的某些方法需要声明，但又不知道如何去实现，那么可以将该方法设定为抽象方法(没有方法体)，该类设定为抽象类。
- 具有抽象方法的类，必须声明成抽象类。(作用: 就是为了让子类实现该抽象方法)
- 细节
    - 抽象类无法无法被实例化(完全为了继承而使用)
    - 抽象类可以没有abstract方法，而且也可以有实现的方法
    - abstract只能修饰类和方法，不能修饰属性和其他的
    - 抽象类还是一个类, 可以有构造器、静态成员、非静态成员
    - 如果一个类继承自抽象类，则它必须实现父类(以及超类直到顶级父类)的**所有**抽象方法，除非自己也声明为abstract类
    - 抽象方法中不可以出现: private、static、final, 因为private和final都不允许子类重写, 而static的方法也不能被重写。

### 26、设计模式二: 模板模式
- 需求: 多个类执行不同的job，需要统计每个类执行job的持续时间
- 问题: 在每个job中存在许多公用的部分
- 解决: 
    - 创建一个抽象类，将job()作为抽象方法让子类去完成重新写
    - 在抽象类中，写一个调用job()的方法，该方法calculateTimes用于计算调用job()的时间
    - 在子类中只需要重写抽象类的job()方法，再调用父类calculateTimes方法即可。
- 子类重写job()方法后，由子类运行对象调用calculateTimes时，在运行到job()时会触发动态绑定机制，只会执行子类的重写后的job()方法

### 27、接口-关键字interface
- 接口: 规定了需要实现哪些方法(类似于abstract方法), 某个类要使用的时候需要根据具体情况把这些方法写出来。接口中方法是默认abstract和public，因此在方法中可以省略这两个关键字。(注意接口本身具有有public和默认(包外无法访问)两种权限)
- 当某个类implements接口时(此时可以看成这个类是接口的子类, 可以适用向上转型)，就需要实现该接口规定的方法(类似于实现abstract方法)
- 在jdk8之后接口可以有静态方法和默认方法.
- 细节: 
    - 接口无法被实例化(完全为了继承而使用)
    - 接口中所有方法都是public方法, 接口中的抽象方法可以不用abstract使用，因此可以省略abstract和public关键字。因此在子类中所有实现的抽象方法都是public的(因此子类不能缩小父类的访问权限)
    - 一个普通类implement接口，需要实现接口的所有抽象方法
    - 一个抽象类implement接口，可以不用实现接口的抽象方法
    - 一个类同时可以implement多个接口(类只能单一继承)
    - 接口中的所有的属性都是public static final。因此接口中的属性必须在定义时就完成初始化.(因为接口没有静态代码块)
    - 接口中属性的访问形式: 接口名.属性名
    - 接口不能继承其他类，但是接口可以extends接口
    - 接口只具有两种权限【默认、public】(类也是只有两种修饰符)
- 实现接口 VS 继承类
    - 继承的价值主要在于: 解决代码的 复用性 和 可维护性
    - 接口的价值主要在于: 设计, 设计好各种规范(方法), 让其它类去实现这些方法, 即更加灵活
    - 继承满足 is - a 的关系, 接口只用满足 like - a的关系
    - 接口在一定程度上实现了代码的解耦【即: 接口的规范性 + 动态绑定】
- 多态: 接口类型的变量可以 指向 实现了接口的类的对象实例 (“向上转型”)
    - 多态参数: 在方法的定义中形参类型定义为接口，则该方法可以接收实现接口的类的实例作为参数传递。
    - 多态数组: 接口类型数组可以存放所有实现了该接口的类的对象实例。
        - 依然可以使用instanceof进行运行类型的判断(是否为子类对象)
        - 也可以进行“向下转型”
    - 多态传递: 如接口B继承自接口A，有一个class实现了接口B，就相当于这个class也是实现了接口A。(因为class实现了接口B, 那么class也一定实现了接口A的所有抽象方法)

### 28、内部类
- 一个类的内部有完整的嵌套了另一个类结构，被嵌套的类称为内部类。内部类最大的特点就是可以直接访问私有属性，并且可以体现出类与类的包含关系。
- 嵌套其他类的类称为外部类(outer class). 是我们类的第五大成员【属性、方法、构造器、代码块、内部类】
- 分类：
    - 定义在外部类的局部位置上(比如在方法内)
        - 1) 局部内部类——有类名
        - 2) 匿名内部类——没有类名
    - 定义在外部类的成员位置上
        - 1) 成员内部类(不使用static修饰)
        - 2) 静态内部类(使用static修饰)
- **局部内部类**: 定义在外部类的局部位置, 一般是方法或代码块中定义
    - 局部内部类可以**直接访问**外部类的所有成员(方法/属性), 包括私有成员
    - 不能添加访问修饰符(public、protected、private), 因为局部内部类的地位是一个局部变量。局部变量不能使用访问修饰符。但是可以使用final修饰(则该内部类就无法被继承了)
    - 作用域: 只能在定义的方法中使用，或者在定义他的代码块中使用。在作用域中通过创建内部类的实例来调用内部类的方法
    - 外部**其他类** 不能访问局部内部类(因为 局部内部类其实就是一个局部变量的地位) 
    - 如果局部内部类和外部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用【外部类名.this.成员】来访问。(外部类名.this 其实表示的是哪个对象调用了该方法，则 外部类名.this 指向的是谁的地址)
- **匿名内部类(重要)**
    - 应用场景: 如果有个类我只想使用一次，没有必要再标准定义一个类和实例化。
    - (1)本质是个类，(2)但是定义在外部类的局部位置(需要遵守局部的那些规则)，(3)该类显式的类名, (4)同时它还是一个对象
    - 基本语法:
    ```
    new 类名/接口名 (参数列表){
        类体(一般是重写/实现方法)
    };
    ```
    - 匿名类内部类的存在只是为了简化代码。很多时候我们为了实现一个接口而创建一个类，而该类可能只会使用一次，但是我们却需要做很多的标准化工作(定义一个类，实例化该类)，如果这个情况出现很多次(以不同方式实现某个接口的某个方法)，则我们会创建出很多只使用一次的类。匿名内部类的存在则解决了该问题，通过简略的实现/重写方法并直接实例化。
    - 匿名内部类的运行类型 是由系统自动分以配的一个名为 Outer02$1 的一个类(可通过getClass()查看)。
    - 类的匿名内部类要点:
        - 其实是创建了继承该类的子类
        - 匿名内部类无法定义构造器(因为匿名内部类都没有名字)，但必须使用到父类的某一个构造器完成实例化(这也就是参数列表中放的东西)
    - 细节:
        - 匿名内部类实际是一句执行命令因此必须有分号; 调用方法也就有两种，第一种是用一个引用接收(正常),还有一种是直接.方法名()。
        - 可以直接访问外部类的所有成员，包括私有成员(局部内部类的特性)
        - 没有访问修饰符, 连final都没有(匿名内部类存在就是就是只是用一次，没必要去继承)
        - 作用域: 只能在定义的方法中使用，或者在定义他的代码块中使用。(匿名内部类都将实例化对象给到了引用了，外部当然不能用了)
        - 外部其他类不能访问匿名内部类
        - 如果匿名内部类和外部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用【外部类名.this.成员】来访问。
    - 引用场景:
        - 将匿名内部类作为实参直接传递
- 成员内部类(没有static修饰的)
    - 定义在外部类的成员位置(不在代码块/方法中)，可以视为一个类的属性的地位。可以添加访问修饰符(public、protected、private)。
    - 可以**直接访问**外部类的所有成员，包括私有的方法/属性。
    - 作用域: 为外部类的整个类体中，可以被外部类的任意方法创建对象。
    - 外部其他类也可以访问到成员内部类(两种方式)
        - 方式一: 外部类实例对象.new Inner(); 注意引用需要采用: 外部类类名.Inner
        - 方式二: 在外部类公开一个方法，返回一个成员内部类的对象。
    - 外部类和成员内部类重名时，内部类访问遵循就近原则, 如果想要访问外部类的成员需要使用 外部类名.this.成员
- 静态内部类(static修饰)
    - 定义在外部类的成员位置(不在代码块/方法中)，可以视为一个类的属性的地位。可以添加访问修饰符(public、protected、private)，并且具有static修饰(与成员内部类最大的差别)
    - 可以**直接访问**外部类的所有**静态成员**，但无法访问非静态成员
    - 作用域: 为外部类的整个类体中，可以被外部类的任意方法创建对象。
    - 外部其他类访问静态内部类(两种方式)
        - 方式一: new 外部类类名.静态内部类()
        - 方式二: 在外部类公开一个方法(如果使用静态的公开方法更方便)，返回一个静态内部类的对象。
    - 外部类和静态内部类属性出现重名时，内部类访问遵循就近原则, 如果想要访问外部类的成员(只能是静态的)需要使用 外部类名.成员 (不用再加this了)

## 第八章节: 枚举和注解(Chapter8)
### 29、枚举enumeration
- 枚举类: 把具体的对象一个一个的列举出来的类，称为枚举类。枚举属于一种特殊的类，里面只包含一组有限的特定的对象
- 适用类型: 当对象实例只有有限的几种情况
- 实现方式(两种):
    - 自定义:
        - 1) 将构造器私有化，不能被外部new 一个实例
        - 2) 去掉set方法，防止属性被修改
        - 3) 在类的内部定义好所存在的四个对象，一般设置为public static final，一般是只读。所以一般是按照全大写的常量名命名规则
    - 使用关键字enum:
        - 1) 将class关键字改为 enum
        - 2) 直接使用 对象名(构造器参数) 即可创建出对象
        - 3) 若有多个常量对象需要创建，则需要将所有常量对象写在一行用, 间隔最后一个带;(要求定义的常量对象定义在类的最前面)，这些常量对象都是public static final的
- 注意事项:
    - 当使用enum关键字开发枚举类的时候，其实是继承了一个叫Enum类，并且enum定义的类是final的。
    - 如果是使用无参构造器创建枚举对象，则小括号都可以省略。
    - 枚举对象定义在类的最前面
    - 我们通过enum关键字构建枚举类时，就不能再继承其他类了(因为enum隐式的继承了Enum类)，但是可以实现接口
- enum类的常用方法：
    - toString(): 父类Enum类已经重写过，返回的是当前对象名, 子类可以重写该方法，用于返回对象的属性信息
    - name(): 返回当前对象名(常量名)，子类不能重写该方法
    - ordinal(): 返回该枚举对象的定义次序，从0开始编号
    - static values(): 返回一个数组，该数组含有所有的枚举对象
    - static valueOf(String): 将根据字符串去在枚举对象中查找并返回结果，要求字符串必须为已有常量名，否则报异常!
    - 枚举对象A.compareTo(枚举对象B): 将枚举对象A的编号 与 枚举对象B的编号进行相减，返回编号的差值

### 30、注解Annotation
- 注解也被称为元数据(Metadata), 用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。
- 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入再代码中的补充信息。
- 在JavaSE中, 注解的使用比较简单，例如标记过时的功能、忽略警告等。当成修饰符使用(一般在被修饰的成员的上一行)
- 基本注解:
    - @Override: 限定某个方法，是重写父类方法，该注解只能用于方法。编译器会进行校验是否真的重写了，否则会编译报错。
    - @Deprecated: 用于表示程序元素(类、方法)已过时，但如果非要使用仍可以通过编译.
    - @SuppressWarnings: 抑制编译警告(作用范围与防止的位置相关)。使用方法@@SuppressWarnings({"unused","unchecked","all"})。警告类型有很多。常见的有以下
        - "all": 忽略所有警告
        - "rawtypes": 忽略没有指定泛型的警告(传参时没有指定泛型的警告)
        - "unused": 忽略没有使用某个变量的警告
        - "all":
- 自定义注解
- 元注解(了解): 修饰注解的注解
    - @Target(ElementType.METHOD)表示被修饰的注解能用在那些地方
    - @Retention: 指定注解的保留时间(范围)
    - @Document: 指被修饰的注解会在javaDoc文档中
    - @Inherited: 被他修饰的注解A将具有继承性，如果某个类使用了注解A则该子类将自动具有该注解

## 第九章节: 异常详解(Chapter9)
### 31、异常概念以及异常体系图
- 在执行过程中所发生的程序中断问题，原因可以分为两大类
    - Error(错误): 由于Java虚拟机无法解决的严重问题。例如JVM系统内部错误,资源耗尽等严重情况(StackOverflowError栈溢出)
    - Exception(异常): 其他因为编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件。Exception主要分类两类：运行时异常【在程序运行过程中发生的异常】、编译时异常【编程时，编译器检查出的异常】
- 异常体系图：
    ```
    ├── 顶级父类:Throwable
        ├── Error类: 没有办法继续运行
        |    ├── StackOverflowError类: 栈溢出错误
        |    └── OutOfMemoryError类: 内存溢出
        └── Exception类: 可以通过try-catch来进行针对性处理
             ├── RuntimeException类(运行时异常类)
             |    ├── NullPointerException: 空指针异常
             |    ├── ArithmeticException: 算数时异常
             |    ├── ArrayIndexOutOfBoundsException: 数组越界异常
             |    ├── ClassCastException: 类型转换异常
             |    └── NumberFormatException: 数字格式异常
             ├── FileNotFoundException类(编译异常的类)
             └── ClassNotFoundException类(编译异常的类)
    ```
- 异常分为两大类：编译时异常/运行时异常
    - 运行时异常，编译器不要求强制处理的异常(编译器检测不出来)。一般是编程时的逻辑错误，程序员因该避免其出现的异常。
    - 编译时异常，是编译器要求必须处置的异常.
- 常见运行时异常
    - 1) NullPointerException: 空指针异常, 当应用程序试图在需要对象的地方使用null，则会抛出该异常
    - 2) ArithmeticException: 算数时异常, 例如，一个整数除以0时会抛出此异常
    - 3) ArrayIndexOutOfBoundsException: 数组越界异常。当用超过数字长度的下标索引数组时会抛出此异常。
    - 4) ClassCastException: 类型转换异常。当在向下转型时编译类型与运行类型没有关系时就会抛出类型转换异常
    - 5) NumberFormatException: 数字格式异常。当程序试图将字符串转化为一种数值类型时，但该字符串不能满足适当格式时，抛出该异常。
- 常见的编译异常
    - SQLException: 操作数据库时，查询表可能发生的异常
    - IOException: 操作文件时，发生的异常
    - FileNotFoundException: 当操作一个不存在的文件时发生的异常
    - ClassNotFoundException: 加载类而该类不存在时，发生的异常
    - EOFException: 操作文件时，到文件末尾发生异常
    - IllegalArgumentException: 参数异常
- 异常处理方式(两种)
    - 第一种: try-catch-finally 程序员在代码中捕获发生的异常，自行处理。
        - 当异常发生时，系统会捕获到异常封装成Exception对象发送给catch，用e接收。
        - 无论try代码块是否有异常发生，使用会执行finally代码块。
    - 第二种: throws, 将发生的异常抛出，交给方法调用者处理。
        - 方法调用者接收到下级throws的异常，也可以通过t-c-f来捕获处理，也可以继续throws扔给上级
        - throws到最顶级的处理者就是JVM，JVM则直接输出异常信息，退出程序。
    - 如果程序员没有选择以上的任何一种机制，则默认采用的是throws

### 33、try-catch异常处理
- try{}块中包含可能出错的代码，catch{}中包含出现错误后执行的方法
- 注意事项:
    - 如果try{}中异常发生了，则异常发生之后的语句都不会执行，而直接进入到catch块中
    - 如果try{}中异常没有发生，则不会进入到catch块中
    - 无论是否发生异常finally{}块中的内容都会被执行。(即使没有catch{}发生了异常也会执行finally{})
    - 一个try{}语句块后面可以捕获不同的异常(如果认为代码块中可能出现多种异常类型，需要进行不同业务的处理)，即使用多个catch{}块, 要求子类异常在前, 父类异常在后。(父类异常包含了子类异常，如果父类异常在第一行就捕获了异常，后面就没有意义了)
    - 如果catch(异常类)中声明的异常类型与真实发生的异常类型不匹配则不会进入到catch块中，如果有多个catch块则会往后以此验证，直到真实发生的异常能够被捕获到。否则由JVM抛出异常。
    - 如果try、catch和finally中都包含有return，则finally中的return语句会覆盖前面的return语句
        - 底层逻辑是: 当执行到catch的return语句时，完成了return语句的执行，只不过会用一个temp变量保存return需要返回的内容，却不直接返回，而是接着去执行finally中的内容。
        - 当finally中内容执行完毕后，如果此时finally中出现了return语句，则会覆盖之前catch中保存的return的内容，如果finally中没有出现return，则会将catch块中提前保存的temp内容返回。

### 34、throws异常处理
- 如果一个方法中的语句执行时，可能会生成某种异常，但并不能确定如何去处理这种异常，则此方法应显示地**声明抛出异常**，表明该方法不对这些异常进行处理，而由该方法的调用者负责处理。
- 在方法声明中用throws 加异常列表，抛出的异常可以是其父类异常。
- 细节:
    - 编译异常必须在编码时就处理，否则无法通过编译
    - 如果没有显式处理，则会默认通过throws处理
    - 子类重写父类方法的时候，如果父类方法使用了throws来抛出某个异常，那么子类重写时也必须抛出同样的异常(或者为父类抛出异常的子类异常，父类异常>=子类异常)
    - 假设方法A定义抛出一个异常，方法B调用方法A时需要处理方法A所抛出的异常，因此方法B要么try-catch方法A的异常，要抛么在方法B中再throws该异常。(如果方法A出的是编译异常则方法B必须得处理这个异常; 如果方法A抛出的是运行异常，则方法B可以不处理【因为有默认处理】)
- throw 关键字:
    - 手动生成异常对象的关键字，常出现在方法体中，throw 后面跟的时实例化的异常类对象
    - 与throws的区别: throws是处理异常的一种方式，在方法声明的地方使用，后面跟的是异常类的类名

### 35、自定义异常
- 如果现有的异常类不能满足程序员要求，则可以自定义异常。
- 步骤:
    - 1) 定义一个类(类名自定)继承自Exception或者RuntimeException
    - 2) 如果继承自Exception，则该自定义异常属于编译异常
    - 3) 如果继承自RuntimeException，则该自定义异常属于运行时异常(一般继承自RuntimeException)


## 第十章节: 常用类(Chapter10)
### 36、包装类 Wrapper
- 针对八种基本数据类型相应的引用类型——包装类。包装类是对基本数据类型的一种扩展
- boolean——Boolean、char——Character。直接继承自Object类
- byte——Byte、int——Integer、long——Long、float——Float、double——Double、short——Short。这几个包装类都是继承自Number类
- jdk5之后，可以自动装箱(int——>Integer)，自动拆箱(Integer——>int)，即直接将int变量赋值给Integer(底层本质调用Integer.valueOf())，或Integer直接赋值给int变量(底层本质调用对象.intValue()进行赋值)。
- 三元运算符是一个运算整体，需要按照运算规则，将低精度的转化为高精度(例如1+1.0=2.0), 包装类依然是同样规则(new Integer(1) + new Double(2.0) = Double(3.0))
- 包装类<——>字符串String (参看第一章节第三部分)
    - 包装类转字符串:
        - 包装类对象.toString()
        - 包装类对象 + ""
        - String.valueOf(包装类对象)
    - 字符串转包装类:
        - 包装类.parseInt(str)
        - new 包装类(str)
- 包装类常用属性/方法：以Integer、Character为例
    - Integer.MAX_VALUE: 返回Integer类型最大值
    - Integer.MIN_VALUE: 返回Integer类型最小值
    - Character.isUpperCse(''): 判断字符是否大写
    - Character.isDigit(''): 判断字符是否为字母

### 37、String类详解(**重要**)
- String对象用于保存字符串，也就是一组字符序列。字符串常量对象是用双引号括起来的字符序列。如:"你好"，"12.01"; 字符串的字符使用Unicode字符编码，一个字符(不区分汉字)占两个字节(16位bit)
- String类实现了以下接口:
    - Serializable: 对象可以实现网络传输、可以序列化
    - Comparable: 对象可以比较大小
- String类中有一个final char[]属性value, 用于保存字符串，将每个字符储存在字符数组中。注意该属性是一个final类型，所以value的**地址**是不能修改的(但char[]数组中的元素是可以改的)
- String对象的两种方式(内存分析)
    - 方式一: 直接赋值 String str = "wyq"。
        - 先查看常量池中是否有"wyq"数据空间，如果有则直接执行该常量池的空间地址；如果常量池中没有，则在常量池中重新创建，然后指向该新创建的常量池的空间地址。因此str最终指向的是**常量池**的空间地址
    - 方式二: 调用构造器创建 String str = new String("wyq")。
        - 该方法将先在**堆**中创建一个对象空间，里面有一个final char[] value属性，value属性指向的是常量池的地址。若常量池中存在"wyq"数据空间，则value指向该常量池地址；若不存在，则在常量池中创建新的空间，value指向该新空间地址。但注意 str 指向的地址是**堆**中的对象地址。
- String修改字符串: 
    - String类中的final char[] 表示不可变(一旦指向了一个对象，则不会再指向其他对象)的字符数组。一旦字符数组常量value属性被分配(指向了常量池中的一个字符串常量"ok"), 将不会再指向常量池的其他地址(字符串常量)。
    - 如果常量池中没有则会重新创建新的字符串常量对象，并且会创建一个新的String对象(将新的String对象中的value指向常量池中的新字符串常量地址)
    - 注意: 在方法调用中, 如果形参是String类型的，根据方法调用的特性，那么形参中传递的将会是String对象地址(假设形参是str)，如果在方法体中将str = new String(xxx)或者 str="xxxx"将会不会对实参造成任何影响，因此以上两个语句都将str指向了新的内存地址，此时str将与原来的实参传递的String对象完全没有关系了。因此完全可以将String类类型类比成"值传递"。
- 重要规则: 如果是字符串常量相加(c1 = "a" + "b")，则c1对象指向的是常量池。如果是对象相加(c1 = new String("a") + new String("b")),则c1对象指向的是**堆**中String对象地址
- String类的常见方法
    - 对象.equals(String): 区分大小写，判断内容是否相等
    - 对象.length(): 返回字符串长度(字符个数)
    - 对象.indexOf(char/String): 获取字符在字符串第1次出现的下标，找不到返回-1。(也可以是子字符串)
    - 对象.lastIndexOf(char/String): 获取字符在字符串最后一次出现的下标，找不到返回-1 
    - 对象.charAt(int): 获取指定下标处的字符(字符串不能使用a\[index]方式获取字符)
    - 对象.substring(int1,int2): 截取字符串子串，起始位置从[int1, int2)结束
    - 对象.comparTo(String): 比较两个字符串大小(字典序)，会返回一个数值(能分出大小的字符之差)
    - 对象.toCharArray(): 转化为字符串数组
    - 对象.concat(String): 将字符串进行拼接。 
    - String.format(String对象, 变量1, 变量2, ....): 将变量插入到字符串中。 注意在String对象中需要有占位符%s(由字符串替换), %d(由整数替换), %.2f(使用小数替换，且保留小数点两位), %c(由char类型替换)，后面的变量会按顺序插入，但要注意变量类型与占位符匹配。

### 38、StringBuffer类介绍(**重要**)
- StringBuffer类是对String类的增强: 代表可变的字符序列，可以对字符串内容进行增删。很多方法与String相同，但StringBuffer是可变长度的。(StringBuffer是一个容器)
- StringBuffer类 的直接父类是 AbstractStringBuilder，实现了Serializable接口。
- 在父类AbstractStringBuilder中存在一个属性char[] value, 该属性就是存放字符串内容的数组，且该属性非final的，因此字符串内容存放在**堆**中
- String 对比 StringBuffer
    - String保存的是字符数组常量(当final char[] 指向了常量池中的一个"字符串常量"后将会不在被修改), 因此每次修改字符串，其实就是会创建新的String对象(让新的String对象中的final char[]指向新的"字符串常量"), 效率特别低。
    - StringBuffer保存的是字符数组变量(char[] value)，该数组value的地址指向是可以改变的，每次StringBuffer的更新其实是在更新value的指向地址。
- 构造器解释:
    - 默认无参构造器是创建一个16大小的char[]
    - 也可以通过构造器指定char[]的大小
    - 通过给定一个字符串来创建情况, 会创建一个长度为str.length+16大小的char[]，并将str添加进char数组中。
- String类 和 StringBuffer类转化
    - String类 ——> StringBuffer类
        - 方式一: StringBuffer(String对象)
        - 方式二: 使用StringBuffer对象的append方法，即对象.append(String)
    - StringBuffer类 ——> String类
        - 方法一: 使用 StringBuffer对象.toString() 得到
        - 方法二: 直接使用String构造器
- 常用方法:
    - 对象.append(String): 在StringBuffer对象后面增加字符串。
    - 对象.delete(int1, int2): 删除下标从[int1, int2)的字符内容。
    - 对象.replace(int1, int2, String对象): 将[int1, int2)的字符内容替换成String对象的内容
    - 对象.insert(int, String): 在下标为int的位置，插入String对象，原本后面的内容往后移。

### 39、StringBuilder详解
- 一个可变的字符序列。此类提供了一个与StringBuffer兼容的API，但不保证同步(非线程安全)。该类被设计作为StringBuffer的一个简易替换，当字符串缓冲区只被**单个线程**使用的时候，优先使用该类。
- StringBuilder类 继承自 AbstractStringBuilder类(与StringBuffer类完全一样的继承关系)
- StringBuilder的构造器与前文提到的StringBuffer一样，不再详述。
- StringBuilder的value也是储存在堆中。
- String、StringBuffer、StringBuilder对比
    - String: 不可变字符序列，修改效率低，但服用率高
    - StringBuffer: 可变序列、修改效率高，线程安全
    - StringBuilder: 可变字符序列，修改效率最高，线程不安全
    - String的大量增加操作会导致大量副本字符串对象留存在内存中，降低效率，因此需要对字符串做大量修改的操作时，不采用String类
- 应用场景:
    - 字符串存在大量的修改操作，一般使用StringBuffer和StringBuilder
    - 字符串存在大量的修改操作，并且是单线程，使用StringBuilder
    - 字符串存在大量的修改操作，是对线程，使用StringBuffer
    - 如果字符串很少修改，但是被多个对象引用，使用Sting，不如配置信息等情况。

### 40、Math类介绍
- Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数
- 方法均为静态方法，因此直接采用类名调用即可
- 常用的方法:
    - Math.abs(): 求绝对值
    - Math.pow(a, b): 求a的b次幂
    - Math.ceil(double): 向上取整，返回 >= double 的最小整数
    - Math.floor(double): 向下取整, 返回 <= double 的最大整数
    - Math.round(double): 四舍五入
    - Math.sqrt(double): 开方
    - Math.random(): 返回\[0,1)的随机小数
        - 获取\[a,b]的随机整数: (int) ((b-a+1) * Math.random + a)
        - 获取\[a,b)的随机整数: (int) ((b-a) * Math.random + a)
    - Math.min(a, b): 返回a,b中的最小值
    - Math.max(a, b): 返回a,b中的最大值

### 41、Arrays类介绍
- Arrays类中包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)
- 常见方法(基本都是静态方法)
    - Arrays.toString(基本类型的数组): 将返回数组的字符串表示
    - Arrays.sort(基本类型的数组): 将传入的数组进行排序，无返回值，将直接更改数组arr
        - 可以传入一个Comparator接口的实现实例，从而完成定制排序。要求实现compare(Object o1, Object o2)方法。若返回1，则o1在后面；若返回-1, 则o1前面。
    - Arrays.binarySearch(arr, num): 通过二分法查找有序数组(必须是从小到大排好序的数组)中num所在的下标，返回下标。如果num不在数组中则返回num应该在数组中的位置-(index+1)
    - Arrays.copyOf(arr, int): 将返回一个新的数组，新数组的元素是arr数组的前int个。如果int=0则返回空数组【】,如果int大于arr的长度，则多余的部分用null填补(数组扩容常用)。
    - Arrays.fill(arr, num): 将使用num替换arr数组中所有的元素。该方法无返回值，将会直接修改arr
    - Arrays.equals(arr1, arr2): 将比较两个数组中的元素是否完全一致，返回boolean
    - Arrays.asList(1,2,3,4,5): 将数据转化成一个List集合(List是一个接口类)，返回的是Arrays的一个静态内部类ArrayList

### 42、System类
- 常用方法：
    - System.exit(参数): 退出当前程序，并给出退出状态。0表示正常状态(主动退出一般都写0)
    - System.arraycopy(arr1, index, arr2, start, length): 将arr1数组中从index索引位置开始拷贝, 将元素挨个拷贝到arr2数组中。arr2数组将从start索引开始接收拷贝的元素，将接收length个元素。异常：如果arr1中从index开始没有length个元素，则会报数组越界异常。
    - System.currentTimeMillis(): 返回距离1970-1-1 0:0:0的毫秒数。返回的是int类型
    - System.gc(): 调用垃圾回收机制

### 43、BigInteger类、BigDecimal类(大数处理)
- 当编程中需要处理大数值的数时，long和double类型就不够用了，因此衍生出BigInteger、BigDecimal
- BigInteger: 用于处理大数值的整数
    - 将大数用字符串的方式传入构造器
    - 在对BigInteger对象进行运算(+、-、*、/)时需要采用指定的方法，不能直接使用运算符
        - 对象.add(long/BigInteger): 将两个数相加，返回BigInteger对象
        - 对象.multiply(long/BigInteger): 将两个数相乘
        - 对象.subtract(): 将两个数相减
        - 对象.divide(): 将两个数相除
- BigDecimal: 用于保存精度更高的浮点数(double会自动将超过限制的小数位数省略)
    - 将高精度的数值用字符串的方式传入构造器
    - BigDecimal的运算也需要使用对应的方法才能进行
        - 对象.add(): 将两个数相加，返回BigInteger对象
        - 对象.multiply(): 将两个数相乘
        - 对象.subtract(): 将两个数相减
        - 对象.divide(除数, 精度参数): 将两个数相除, 很可能出现除不尽的情况此时就会抛出异常ArithmeticException。因此在使用高精度除法时，需要指定精度参数BigDecimal.ROUND_CEILING(保留分子的精度)

### 44、日期类(三代日期类)
- 第一代: Date类——精确到毫秒，代表特定的瞬间
    - new Date(): 得到当前系统时间。默认输出格式为国外格式
        - 也可以在构造器中传入long类型数值，通过毫秒数来得到时间。
    - SimpleDateFormat类: 常和Date类一起使用，用于格式化和解析日期的具体类。它允许将日期格式化为文本，或将文本转化为日期，并进行规范化输出。 
        - 创建SimpleDateFormat对象，同时指定相应的格式(自行查询), 传入字符串
        - SimpleDateFormat对象.format(Date对象): 即可得到格式化后的String
        - SimpleDateFormat对象.parse(String): 将会根据指定格式，将String转化为一个Date对象
- 第二代: Calendar类
    - Calendar构造器是protected无法被直接访问，因此需要使用getInstance()方法来得到Calendar对象
    - Calendar类是一个抽象类，它为特定瞬间与一组如YEAR、MONTH、DAT_OF_MONTH、HOUR等日历字段之间的转换提佛那个了一些方法，并为操作日历字段(例如获得下星期的日期)提供过了一些方法。
    - 通过Calendar.getInstance()得到Calendar对象，可以使用 对象.get()方法来获取相关的日期的字段。
        - 对象.get(Calendar.YEAR): 获取当前Calendar对象的年信息。
        - 对象.get(Calendar.MONTH): 获取当前Calendar对象的月信息(注意月的编号从0开始到11结束)。
        - 对象.get(Calendar.HOUR): 获取当前Calendar对象的时间中时信息(注意这是12小时制的时，如果想获取24小时制的时需要使用HOUR_OF_DAY字段)
    - Calendar没有提供格式化方法，因此需要我们自己根据属性信息来组合输出。
- 第三代: LocalDate(日期)、LocalTime(时间)、LocalDateTime(日期时间)
    - LocalDateTime.now(): 返回当前包含日期和时间的 LocalDateTime对象。如果只想得到日期则使用 LocalDate.now()即可。接下来调用不同方法即可完成对日期时间的获取。例如：对象.getYear(): 可以获得年的信息
    - DateTimeFormatter类: 可以对LocalDateTime对象进行格式化
        - DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH小时mm分钟ss秒 E")即可得到DateTimeFormatter对象。
        - 对象.format(LocalDateTime对象): 即可得到格式化后的String
    - Instant:时间戳类
        - 该类类似于Date，并且提供了一系列和Date转化的方式。使用Instant.now()得到当前时刻的Instant对象。
        - Date.from(Instant对象): 得到Date对象
        - Date对象.toInstant(): 得到Instant对象 
    - 可以使用plusDay/minusDay等系列方法，可以得到几天后/几天前的LocalDateTime对象。这些方法需要时自行查找即可
 

## 第十一章节: 集合(Chapter11)
### 45、集合框架介绍
- 数组的不足: 在定义时必须指定长度，不可更改，且增加删除元素比较麻烦。保存的必须时同一类型的元素。
- 集合: 可以动态保存任意多个对象(对象类型可以不同)，提供了一系列方便的操作对象的方法: add、remove、set、get.
- 集合大体框架(**重要**)
    - 集合主要分为两组: 单列集合(存放单个对象)、双列集合(存放键值对)。
    - Collection接口为主要接口的, 单列集合。
        - 子接口List: 常用的重要子接口, 下面是实现了该接口的常用类
            - Vector类: 
            - LinkedList类:
            - ArrayList类: 
        - 子接口Set: 常用的重要子接口, 下面是实现了该接口的常用类
            - TreeSet类:
            - HashSet类:
    - Map接口为主要接口的, 双列集合。
        - Hashtable类:
        - HashMap类:
        - TreeMap类:
        - Properties类:
        - LinkedHashMap类:

### 46、Collection接口的实现类介绍
- Collection实现子类可以存放多个元素,每个元素可以是Object
- 有些Collection的实现类, 可以存放重复的元素，有些不可以
- 有些Collection的实现类, 有些存放的元素有序(List)，有些存放的元素无序(Set)
- Collection接口中常用方法(实现类都需要重写):
    - 对象.add(Object): 添加对象,如果元素是基本类型则会自动装箱
    - 对象.remove(Object/index): 删除元素，可以指定对象删除(该方法返回boolean)，也可以根据下标删除(该方法返回被删除元素)
    - 对象.contains(Object): 查找元素是否存在，会返回boolean值.
    - 对象.size(): 获取元素个数.
    - 对象.isEmpty(): 判断是否为空.
    - 对象.clear(): 清空所有元素。
    - 对象.addAll(Collection): 添加多个元素, 传入一个单列集合2进去，会将集合2中的元素全部加入
    - 对象.containsAll(Collection): 查找多个元素是否都存在
    - 对象.removeAll(Collection): 删除多个元素
- Collection对象遍历: 所有Collection实现类(包括List和Set的实现子类)都可以使用的遍历方法。
    - 方法一: Iterator(迭代器)
        - 所有实现了Collection接口的对象类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象,即可以返回一个迭代器对象Iterator
        - Iterator仅用于遍历集合元素，本身不存放对象。我们将使用while循环遍历出所有元素。
        ```
        Iterator iterator = coll.iterator(); // 得到一个迭代器
        while(iterator.hasNext()){ // 查找是否存在下一个元素
            iterator.next()  // 取出下一个元素对象
        }
        ```
        - 当遍历完后，游标指向最后一行，无法再使用iterator.next()获取对象，会报异常NoSuchElementException。如果想要再次遍历需要重新使用 coll.iterator()获取新游标
    - 方法二: 增强for循环方式
        - for循环可以代替iterator迭代器, 只能用于遍历集合或数组
        - 基本语法
        ```
        for(元素类型 变量名: 集合名/数组名){

        }
        ```
        - 增强for的底层还是迭代器

### 47、List接口的实现类介绍
- List接口是Collection接口的子接口，因此List的子类也需要实现Collection接口的上述方法。
- List接口类特点
    - List集合类中元素是有序的(即添加顺序和取除顺序一致)，并且可以重复。
    - List集合类除了可以采用Collection的遍历方式以外还可以使用索引(对象.get(index))来遍历，List集合类的每个元素都有一个整数型索引记录其位置。
    - 常见的List实现类有ArrayList、Stack、Vector、LinkedList
- List接口常用方法:
    - 对象.indexOf(Object): 返回目标对象在集合中首次出现的位置
    - 对象.add(index, Object): 将对象插入到集合下标为index的位置, 其余元素向后推移
    - 对象.addAll(index, Collection): 从集合的index位置插入参数集合中的所有元素
    - 对象.set(index, Object): 将集合的index位置的元素替换为Object。
    - 对象.subList(fromIndex, toIndex): 返回下标从[fromIndex, toIndex)的子集合
- ArrayList注意事项:
    - ArrayList允许放入多个null空值
    - ArrayList基本等同于Vector，但ArrayList是线程不安全的，多线程不建议使用ArrayList
    - ArrayList底层是由数组来实现存储的。
    - ArrayList中维护了一个Object[]数组——elementData, 如果使用无参构造器得到ArrayList则此时elementData的容量为0, 第一次扩容量为10, 如需在此扩容则每次增加容量的0.5倍量; 如果使用指定容量大小的构造器，则第一次扩容量大小为指定容量的0.5倍
- Vector注意事项:
    - Vector底层也是维护了一个Object[]数组——elementData。
    - Vector是线程同步的, 即线程安全的
    - Vector的扩容机制是按照原始容量的2倍进行扩容(每次扩充1倍原来数量)，无参构造器使用时默认得到的是容量大小为10的Object[]数组；有参构造器(指定容量)
- LinkedList注意事项:
    - LinkedList类是一个实现了双向链表和双端队列的特点(可以在前后增加元素)。
    - LinkedList允许放入多个null空值，但是线程不安全
    - LinkedList中有一个内部类叫做Node，Node对象维护了prev、next、item三个属性，其中通过prev指向前一个节点(Node), next指向后一个节点(Node), 从而实现了双向链表
    - LinkedList底层维护了一个双向链表，LinkedList中有两个属性first和last(这个两个属性类型是Node)，分别指向首节点和尾节点。
    - LinkedList的添加和删除不是通过数组完成的(因此不涉及数组扩容, 而是通过修改Node的指针)，相对效率较高。
- ArrayList和LinkedList的优劣
    - ArrayList底层是数组，LinkedList底层是双向链表，因此LinkedList增删效率较高，ArrayList改查的效率较高(寻址)
    - 一般业务大部分为查询，因此大部分情况会选择ArrayList。也可以根据业务灵活选择，一个模块选择ArrayList，另一个模块选择LinkedList


### 48、Set接口的实现类介绍
- Set接口是Collection接口的子接口，因此Set的子类也需要实现Collection接口的上述方法。
- Set接口实现类特点:
    - 元素储存无序(添加和取出的顺序不一致)，没有索引(因此无法使用索引方式来遍历)
    - 不允许重复元素, 最多包含有一个null
    - 常见的Set接口实现类有HashSet、TreeSet
- HashSet注意事项
    - HashSet实际上是HashMap
        - HashMap底层是由数组 + 链表(红黑树)来实现的。一个数组Node[] 每个元素为Node，且每个Node都是一个链表的首节点，这个数组称为table，Node中会储存元素的hash值以及元素本身。
        - 这样这个table的每一个元素都是一条链表的首节点，随着数据量的增加(Node数量的增加)，当单条链表长度超过8个节点，且数组长度大于64时，将会把当前条链表重构成一颗红黑树(进一步提升存取能力)。
        ```
        class Node{
            int hash; // 集合元素的hash值
            K key;    // 集合元素对象本身
            V value;  // 一个Object,
            Node<K,V> next; // 指向下一个节点形成列表
        }
        ```
    - HashSet不保证元素有序性，取决于hash之后的hash值来确定顺序，当顺序一旦确定将不会改变。
    - HashSet的add方法会返回一个boolean，表示是否添加成功。具体add的底层代码(实际上是HashMap的add方式)参看下面分析:
        - 添加一个元素时首先得到该元素的hash值(调用元素的hashCode()方法来得到), 并使用算法将该hash值转化为索引(这个索引值就是table数组的那个索引位置)。
        - 在table的索引位置查看该位置是否已经存在元素，如果没有则直接加入。
        - 如果table的该索引位置存在元素，则判断索引处的Node与插入的Node是否相等,判断相等的规则如下:
            - Node中hash属性相等(Node中hash属性是储存的对象的hash值) &&
            - (Node中储存对象的地址是否相等 || 调用Node中储存对象.equals()方法来判定，与插入Node是否相等)
        - 如果相等则说明集合中有该元素，放弃插入。
        - 如果不同，则将"挨个"判断该链表中其他Node是否与插入元素相等(相等规则如上), 如果找到相等则放弃插入，如果全部都不相同则在尾部插入该Node
    - HashMap中table表底层扩容逻辑:
        - HashMap对象中会维护int loadFactor(加载因子), int threshold(临界值)，第一次创建table表(Node[]数组)时表的容量是16，而threshold = 表容量 * loadFactor。默认的加载因子是0.75，因此当第一个元素加入table表时，threshold = 12。当table表使用到长度为12时最会开始扩容
        - 将会直接将原来table表长度 * 2得到新的表容量(第一次扩容则table表变为32容量)，同时也会更新threshold = 32 * 0.75 = 24。以此类推。
        - 需要注意的是当每加入一个Node就会使size++(无论Node是加在链表上还是放在table表的某个位置),当size>=threshold时即会触发扩容机制。(简单来说就是table的成功添加的使用次数>=threshold)
    - HashMap中链表树化(红黑树)逻辑:
        - 当某条链表(注意是链表)的长度超过8时,且当前table的容量大于等于64, 则**该条**链表竟会被树化为红黑树。
        - 如果链表长度超过8，但table容量没有大于等于64(无法触发树化机制)，此时会触发扩容机制(就算此时table表没有使用到threshold那么多)，直接翻倍。此时该条链表的长度将会超过8(因为没有树化但元素仍被链接在该条链表上了)
- LinkedHashSet注意事项
    - LinkedHashSet是属于HashSet的子类
    - LinkedHashSet底层是一个LinkedHashMap(维护了一个数组 + 双向链表)，注意对比HashMap
    - LinkedHashSet根据元素的hashCode值类确定元素的储存位置，**同时**使用双线链表维护元素的次序(因此遍历顺序与插入顺序是一致的)
    - LinkedHashSet不允许添加重复元素。
    - 具体维护双向链表的底层细节:
        - LinkedHashSet维护了一个hash表(类似于HashSet中的table表，是一个Node[]), 当添加第一个元素时先求hash值，再根据hash值得到hash表中的索引，将该第一个元素添加进该索引。注意: LinkedHashSet的Node继承自HashMap.Node, 并且还扩展出两个属性before、after，用于维护全局双向链表。
        ```
        static class Entry extends HashMap.Node {
            Entry before, after; // 增加了两个指针
            Entry(int hash, K key, V value, Node next) {
                super(hash, key, value, next);
            }
        }

        ```
        - 添加第二个元素时，还是按照上述顺序先求hash值再求索引，但是注意无论第二个元素添加到何处，都必须将Node的before指针指向第一个添加的元素，同时第一个添加的元素的after指针指向第二个元素。(注意next指针还是指向当前hash表同一索引元素)
        - 换句话说LinkedHashSet在原来HashSet维护hash表的基础上还增加了一个总体的双向链表用于保证元素插入与遍历的有序性。


### 49、
### 50、
### 51、
### 52、




































